package carcassonne.view;

import carcassonne.controller.WindowLogic;
import carcassonne.model.Coordinates;
import carcassonne.model.Rotation;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;
import java.awt.*;
import java.awt.event.*;
import java.util.HashSet;
import java.util.Set;

/**
 * This is a part of Carcassonne project.
 * The project is created for learning and practicing java
 * and not intended for distribution.
 * Created by Andrey on 11/01/16.
 */
public class GameWindow extends JFrame implements ViewWindow{
    private final WindowLogic windowLogic;

    //<editor-fold desc="Generated by Visual Swing">
    private JPanel rootPanel;
    private JPanel gamePanelArea;
    private JPanel rightColumn;
    private JLabel tilesLeft;
    private JLabel currentPlayer;
    private JLabel numberOfFollowers;
    private JButton endTurnButton;
    private JPanel tilePreviewArea;
    private JPanel playerColor;
    private JButton confirmTileButton;
    private JLabel currentPoints;
    private JSlider scaleSlider;
    private JPanel tableContainer;
    //</editor-fold>

    private JDialog         gameEndWindow = new GameEndWindow();
    private JPanel          tilePreview;
    private JScrollPane     tableScrollPane;
    private JTable          playersStatsTable;
    private TableModel      tableData;
    private GamePanel       gamePanel;
    private DrawableTile    currentTile;
    private boolean         tilePreviewEnabled;
    private Set<Coordinates>                possibleTileLocations;
    private Set<double[]>                   followerPossibleLocations;
    private Set<DrawablePlacedFollower>     drawablePlacedFollowers = new HashSet<>();

    public GameWindow(WindowLogic windowLogic) {
        super("Carcassonne");
        this.windowLogic = windowLogic;
        setContentPane(rootPanel);
        setSize(800,600);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        tilePreview = new TilePreview();
        tilePreviewArea.add(tilePreview);
        gamePanel = new GamePanel();
        gamePanelArea.add(gamePanel);

        tableData = new AbstractTableModel() {
            @Override
            public int getRowCount() {
                return 3;
            }

            @Override
            public int getColumnCount() {
                return 3;
            }

            @Override
            public Object getValueAt(int rowIndex, int columnIndex) {
                return "Anton";
            }
        };

        playersStatsTable = new JTable(tableData);
        playersStatsTable.setPreferredScrollableViewportSize(new Dimension(100, 80));

        tableScrollPane = new JScrollPane(playersStatsTable);
        tableContainer.add(tableScrollPane);

        //<editor-fold desc="Listeners">
        endTurnButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                windowLogic.updateEndTurnButton();
            }
        });

        confirmTileButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                windowLogic.updateTileConfirmedButton();
            }
        });

        setVisible(true);
        scaleSlider.addChangeListener(new ChangeListener() {

            @Override
            public void stateChanged(ChangeEvent e) {
                JSlider source = (JSlider)e.getSource();
                gamePanel.changeScale(source.getValue());
            }
        });

        this.addMouseWheelListener(new MouseWheelListener() {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e) {
                int value = scaleSlider.getValue();
                value += 2 * e.getWheelRotation();
                scaleSlider.setValue(value);
            }
        });
        //</editor-fold>
    }

    //<editor-fold desc="Setters used by controller">
    @Override
    public void setConfirmTileButtonEnabled(boolean b) {
        confirmTileButton.setEnabled(b);
    }

    @Override
    public void setConfirmTileButtonText(String text) {
        confirmTileButton.setText(text);
    }

    @Override
    public void setEndTurnButtonEnabled(boolean b) {
        endTurnButton.setEnabled(b);
    }

    @Override
    public void setPlayerColorRemainder(Color color) {
        playerColor.setBackground(color);
    }

    @Override
    public void setCurrentPlayerName(String currentPlayer) {
        this.currentPlayer.setText(currentPlayer);
    }

    @Override
    public void setTilesNumber(String tilesNumber) {
        this.tilesLeft.setText("Tiles left: " + tilesNumber);
    }

    @Override
    public void setNumberOfFollowers(String numberOfFollowers) {
        this.numberOfFollowers.setText("Followers: " + numberOfFollowers);
    }

    @Override
    public void setCurrentPoints(String currentPoints) {
        this.currentPoints.setText("Current points: " + currentPoints);
    }

    @Override
    public void addTileOnTable(DrawableTile tile) {
        gamePanel.addTileOnTable(tile);
    }


    public void setTilePreviewEnabled(boolean b) {
        tilePreviewEnabled = b;
    }

    @Override
    public void setPossibleTileLocations(Set<Coordinates> possibleTileLocations) {
        this.possibleTileLocations = possibleTileLocations;
    }

    @Override
    public void setCurrentTile(DrawableTile drawableTile) {
        this.currentTile = drawableTile;
    }

    @Override
    public DrawableTile getCurrentTile() {
        return currentTile;
    }

    @Override
    public void setPossibleFollowerLocations(Set<double[]> followerLocations) {
        this.followerPossibleLocations = followerLocations;
    }

    @Override
    public void setDrawablePlacedFollowersSet(Set<DrawablePlacedFollower> drawablePlacedFollowers) {
        this.drawablePlacedFollowers = drawablePlacedFollowers;
    }

    //</editor-fold>

    @Override
    public void displayEndgameWindow() {
        gameEndWindow.setVisible(true);
    }

    @Override
    public void repaintWindow() {
        tilePreview.repaint();
        gamePanel.repaint();
    }

    private class TilePreview extends JPanel {
        TilePreview() {
        }

        @Override
        public void paintComponent(Graphics g) {
            super.paintComponent(g);
            if (tilePreviewEnabled) {
                g.drawImage(currentTile.getBufferedImage(), 0, 0, null);
            }
        }
    }

    private class GamePanel extends JPanel {
        private double  windowLocalX = 235;
        private double  windowLocalY = 244;
        private double  previousScaleMultiplier = 2;
        private double  tileSize = 90;
        private boolean firstMouseDrag = true;
        private int     previousMouseX = 0, previousMouseY = 0;
        private int     MIN_TILE_SIZE = 45;
        private int     TILE_SIZE_VARIATION = 90;
        private Set<DrawableTile>   tilesOnTable = new HashSet<>();
        private final int           RECTANGLE_DIVIDER = 9;            // used to compute rectangleMargin of possible tile rectangle
        private double              rectangleMargin = tileSize / RECTANGLE_DIVIDER;

        GamePanel() {
            this.setBackground(Color.GRAY);
            this.addMouseListener(new MouseListener() {

                @Override
                public void mouseClicked(MouseEvent e) {
                    if ((e.getX() >  windowLocalX + tileSize * windowLogic.getCurrentTileX() &&
                         e.getX() < (windowLocalX + tileSize * windowLogic.getCurrentTileX() + tileSize)) &&
                        (e.getY() >  windowLocalY + tileSize * windowLogic.getCurrentTileY() &&
                         e.getY() < (windowLocalY + tileSize * windowLogic.getCurrentTileY() + tileSize))) {

                        windowLogic.clickOnCurrentTile();
                    } else {
                        windowLogic.clickOffCurrentTile();
                    }

                    for (Coordinates coordinates: possibleTileLocations) {
                        if ((e.getX() >  windowLocalX + tileSize * coordinates.getX() &&
                             e.getX() < (windowLocalX + tileSize * coordinates.getX() + tileSize)) &&
                            (e.getY() >  windowLocalY + tileSize * coordinates.getY() &&
                             e.getY() < (windowLocalY + tileSize * coordinates.getY() + tileSize))) {

                            windowLogic.clickOnPossibleLocation(coordinates.getX(), coordinates.getY());
                            break;
                        }
                    }

                    if (followerPossibleLocations != null) {
                        for (double[] followerPosition : followerPossibleLocations) {
                            double[] rotatedFollowerPosition = rotateMultipliers(followerPosition, currentTile.getRotation());
                            if ((e.getX() > windowLocalX + tileSize * windowLogic.getCurrentTileX() + tileSize * rotatedFollowerPosition[0] - 12) &&
                                (e.getX() < windowLocalX + tileSize * windowLogic.getCurrentTileX() + tileSize * rotatedFollowerPosition[0] + 12) &&
                                (e.getY() > windowLocalY + tileSize * windowLogic.getCurrentTileY() + tileSize * rotatedFollowerPosition[1] - 12) &&
                                (e.getY() < windowLocalY + tileSize * windowLogic.getCurrentTileY() + tileSize * rotatedFollowerPosition[1] + 12)) {

                                windowLogic.clickOnCurrentTile(followerPosition[0], followerPosition[1]);
                            }
                        }
                    }
                    repaint();
                }

                @Override
                public void mouseReleased(MouseEvent e) {
                    firstMouseDrag = true;
                }

                //<editor-fold desc="Empty implementations">
                @Override
                public void mousePressed(MouseEvent e) {}

                @Override
                public void mouseEntered(MouseEvent e) {}

                @Override
                public void mouseExited(MouseEvent e) {}
                //</editor-fold>
            });
            this.addMouseMotionListener(new MouseMotionAdapter() {
                @Override
                public void mouseDragged(MouseEvent e) {
                    super.mouseDragged(e);

                    int mouseX = e.getX();
                    int mouseY = e.getY();
                    if (firstMouseDrag) {
                        /*
                         * when mouse is clicked but not yet moved
                         * windowLocal coordinates should not change
                         */
                        firstMouseDrag = false;
                        previousMouseX = mouseX;
                        previousMouseY = mouseY;
                    } else {
                        windowLocalX -= previousMouseX - mouseX;
                        previousMouseX = mouseX;
                        windowLocalY -= previousMouseY - mouseY;
                        previousMouseY = mouseY;
                    }

                    repaint();
                }

                @Override
                public void mouseMoved(MouseEvent e) {
                    super.mouseMoved(e);
                }
            });
        }

        void changeScale(double scale) {
            double windowWidth = this.getWidth();
            double windowHeight = this.getHeight();
            tileSize = MIN_TILE_SIZE + (int)(TILE_SIZE_VARIATION  * scale / 100);
            rectangleMargin = (tileSize / RECTANGLE_DIVIDER);

            /*
             * Everything below moves the windowLocalX and Y in such way that
             * when scale happens, center pixel stays in the center
             */
            double scaleMultiplier = 1 + 2 * (scale / 100);

            double offsetX = windowWidth / 2 - windowLocalX;
            double newOffsetX = offsetX / previousScaleMultiplier;
            newOffsetX *= scaleMultiplier;
            windowLocalX =  windowWidth / 2 - newOffsetX;


            double offsetY = windowHeight / 2 - windowLocalY;
            double newOffsetY = offsetY / previousScaleMultiplier;
            newOffsetY *= scaleMultiplier;
            windowLocalY = windowHeight / 2 - newOffsetY;

            previousScaleMultiplier = scaleMultiplier;
            repaint();
        }

        void addTileOnTable(DrawableTile tile) {
            if (tile.noCoordinates())
                throw new RuntimeException("Cannot draw placed tile with no coordinates");
            tilesOnTable.add(tile);
            repaint();
        }

        @Override
        public void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2 = (Graphics2D) g;

            for (DrawableTile tile: tilesOnTable) {
                g.drawImage(tile.getBufferedImage(),
                        (int) (windowLocalX + tileSize * tile.getX()),
                        (int) (windowLocalY + tileSize * tile.getY()),
                        (int) tileSize, (int) tileSize, null);
            }

            /*
             * Sometimes possibleTileLocations is null for a moment when the window is displayed.
             * The programme works ok after.
             */
            if (windowLogic.displayPossibleLocations() && possibleTileLocations != null) {
                for (Coordinates coordinates: possibleTileLocations) {
                    g.drawRect((int) (windowLocalX + tileSize * coordinates.getX() + rectangleMargin),
                            (int) (windowLocalY + tileSize * coordinates.getY()  + rectangleMargin),
                            (int) (tileSize - 2 * rectangleMargin),
                            (int) (tileSize - 2 * rectangleMargin));
                }
            }

            if (windowLogic.isCurrentTileOnTheTable()) {
                g.drawImage(currentTile.getBufferedImage(),
                        (int) (windowLocalX + tileSize * windowLogic.getCurrentTileX()),
                        (int) (windowLocalY + tileSize * windowLogic.getCurrentTileY()),
                        (int) tileSize, (int) tileSize, null);
            }

            if (windowLogic.isFollowerPlaceDisplayed()) {
                g.setColor(windowLogic.getCurrentPlayerColor());
                g2.setStroke(new BasicStroke(2));
                for (double[] xyMultipliers: followerPossibleLocations) {
                    drawFollowerPossibleLocation(g, xyMultipliers);
                }
            }

            if (windowLogic.isTemporaryFollowerDisplayed()) {
                drawPlacedFollower(g, windowLogic.getCurrentFollowerLocation());
            }

            for (DrawablePlacedFollower follower: drawablePlacedFollowers) {
                g.setColor(follower.getColor());
                double[] xyMultipliers = rotateMultipliers(follower.getXyMultipliers(), follower.getRotation());
                drawPreviouslyPlacedFollower(g, xyMultipliers, follower.getTileX(), follower.getTileY());
            }
        }

        private void drawFollowerPossibleLocation(Graphics g, double[] xyMultipliers) {
            xyMultipliers = rotateMultipliers(xyMultipliers, currentTile.getRotation());
            double circleDiameter = tileSize / 4;
            double circleRadius   = tileSize / 8;
            g.drawOval((int) (windowLocalX + tileSize * windowLogic.getCurrentTileX() + tileSize * xyMultipliers[0] - circleRadius),
                       (int) (windowLocalY + tileSize * windowLogic.getCurrentTileY() + tileSize * xyMultipliers[1] - circleRadius),
                       (int) circleDiameter, (int) circleDiameter);
        }

        private void drawPlacedFollower(Graphics g, double[] xyMultipliers) {
            xyMultipliers = rotateMultipliers(xyMultipliers, currentTile.getRotation());
            double circleDiameter = tileSize / 4;
            double circleRadius   = tileSize / 8;
            g.fillOval((int) (windowLocalX + tileSize * windowLogic.getCurrentTileX() + tileSize * xyMultipliers[0] - circleRadius),
                       (int) (windowLocalY + tileSize * windowLogic.getCurrentTileY() + tileSize * xyMultipliers[1] - circleRadius),
                       (int) circleDiameter, (int) circleDiameter);
        }

        private void drawPreviouslyPlacedFollower(Graphics g, double[] xyMultipliers, int tileX, int tileY) {
            double circleDiameter = tileSize / 4;
            double circleRadius   = tileSize / 8;
            g.fillOval((int) (windowLocalX + tileSize * tileX + tileSize * xyMultipliers[0] - circleRadius),
                    (int) (windowLocalY + tileSize * tileY + tileSize * xyMultipliers[1] - circleRadius),
                    (int) circleDiameter, (int) circleDiameter);
        }

        private double[] rotateMultipliers(double[] xyMultipliers, Rotation angle) {
            switch (angle) {
                case DEG_0:
                    return xyMultipliers;
                case DEG_90:
                    return new double[] {1 - xyMultipliers[1], xyMultipliers[0] };
                case DEG_180:
                    return new double[] {1 - xyMultipliers[0], 1 - xyMultipliers[1]};
                case DEG_270:
                    return new double[] {xyMultipliers[1], 1 - xyMultipliers[0]};
            }
            return xyMultipliers;
        }
    }
}
